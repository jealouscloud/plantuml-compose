"""Use case diagram builder with context manager syntax.

When to Use
-----------
Use case diagrams show WHAT a system does from the user's perspective.
Use when:

- Capturing functional requirements
- Defining system boundaries
- Identifying actors and their goals
- Communicating with stakeholders

NOT for:
- HOW the system works internally (use sequence/activity)
- Data structures (use class diagram)
- Deployment (use deployment diagram)

Key Concepts
------------
Actor:     Someone/something outside the system (User, Admin, External API)
Use Case:  A goal the system helps actors achieve (Login, Checkout, Search)
System:    Boundary (rectangle) showing what's inside vs outside

Relationships:

    actor ──> usecase       Actor interacts with use case
    generalizes ──▷         Inheritance (Admin ──▷ User)

    requires (<<include>>):
        Base ALWAYS needs the required use case
        Checkout ··> Validate Cart : <<include>>

    optional_for (<<extends>>):
        Extension MAY be triggered during base
        Apply Coupon ··> Checkout : <<extends>>

              ┌────────────────────────────────────┐
     Actor    │  System Boundary                   │
       │      │                                    │
     ┌─┴─┐    │   (Browse)    (Checkout)           │
     │ o │────│─────○───────────○                  │
     └─┬─┘    │                 │                  │
       │      │                 │ <<include>>      │
              │                 ▼                  │
              │           (Validate Cart)          │
              └────────────────────────────────────┘

Example
-------
    with usecase_diagram(title="Shopping System") as d:
        user = d.actor("Customer")
        browse = d.usecase("Browse Products")
        checkout = d.usecase("Checkout")
        validate = d.usecase("Validate Cart")

        d.arrow(user, browse)
        d.arrow(user, checkout)
        d.requires(checkout, validate)

    print(render(d.build()))
"""

from __future__ import annotations

from contextlib import contextmanager
from typing import Iterator, Literal

from ..primitives.common import (
    ColorLike,
    Direction,
    Footer,
    Header,
    Label,
    Legend,
    LineStyleLike,
    Scale,
    Stereotype,
    StyleLike,
    coerce_direction,
    coerce_line_style,
    validate_style_background_only,
)
from ..primitives.usecase import (
    Actor,
    ActorStyle,
    Container,
    ContainerType,
    Relationship,
    RelationType,
    UseCase,
    UseCaseDiagram,
    UseCaseDiagramElement,
    UseCaseNote,
)


# Type alias for objects that can be used as relationship endpoints
UseCaseRef = Actor | UseCase | str


class _BaseUseCaseBuilder:
    """Base class for use case builders with shared methods."""

    def __init__(self) -> None:
        self._elements: list[UseCaseDiagramElement] = []

    def _to_ref(self, target: UseCaseRef) -> str:
        """Convert a use case element reference to its string form.

        Accepts strings, Actor, or UseCase primitives.
        """
        if isinstance(target, str):
            return target
        return target._ref

    def actor(
        self,
        name: str,
        *,
        alias: str | None = None,
        stereotype: str | Stereotype | None = None,
        style: StyleLike | None = None,
        business: bool = False,
    ) -> Actor:
        """Add an actor.

        Args:
            name: Actor name (spaces and special characters allowed)
            alias: Optional identifier for relationships. If not provided and
                the name contains spaces, an alias is auto-generated by
                replacing spaces with underscores (e.g., "System Admin"
                becomes System_Admin). This ensures PlantUML can reference
                the actor consistently in relationships.
            stereotype: Stereotype annotation
            style: Visual style (background, line, text_color)
            business: Use business variant (actor/)

        Returns:
            The created Actor
        """
        if not name:
            raise ValueError("Actor name cannot be empty")
        stereo = (
            Stereotype(name=stereotype) if isinstance(stereotype, str) else stereotype
        )
        style_obj = validate_style_background_only(style, "Actor")
        a = Actor(
            name=name,
            alias=alias,
            stereotype=stereo,
            style=style_obj,
            business=business,
        )
        self._elements.append(a)
        return a

    def usecase(
        self,
        name: str,
        *,
        alias: str | None = None,
        stereotype: str | Stereotype | None = None,
        style: StyleLike | None = None,
        business: bool = False,
    ) -> UseCase:
        """Add a use case.

        Args:
            name: Use case name (spaces and special characters allowed)
            alias: Optional identifier for relationships. If not provided and
                the name contains spaces, an alias is auto-generated by
                replacing spaces with underscores (e.g., "Browse Products"
                becomes Browse_Products). This ensures PlantUML can reference
                the use case consistently in relationships.
            stereotype: Stereotype annotation
            style: Visual style (background, line, text_color)
            business: Use business variant (usecase/)

        Returns:
            The created UseCase
        """
        if not name:
            raise ValueError("Use case name cannot be empty")
        stereo = (
            Stereotype(name=stereotype) if isinstance(stereotype, str) else stereotype
        )
        style_obj = validate_style_background_only(style, "UseCase")
        uc = UseCase(
            name=name,
            alias=alias,
            stereotype=stereo,
            style=style_obj,
            business=business,
        )
        self._elements.append(uc)
        return uc

    def relationship(
        self,
        source: UseCaseRef,
        target: UseCaseRef,
        *,
        type: RelationType = "association",
        label: str | Label | None = None,
        style: LineStyleLike | None = None,
        direction: Direction | None = None,
        note: str | Label | None = None,
    ) -> None:
        """Add a relationship between elements.

        Args:
            source: Source element (string, Actor, or UseCase)
            target: Target element (string, Actor, or UseCase)
            type: Relationship type
            label: Optional label
            style: Line style (color, pattern, thickness)
            direction: Layout direction hint (up, down, left, right)
            note: Note attached to the relationship
        """
        label_obj = Label(label) if isinstance(label, str) else label
        style_obj = coerce_line_style(style) if style else None
        note_obj = Label(note) if isinstance(note, str) else note
        direction_val = coerce_direction(direction)
        rel = Relationship(
            source=self._to_ref(source),
            target=self._to_ref(target),
            type=type,
            label=label_obj,
            style=style_obj,
            direction=direction_val,
            note=note_obj,
        )
        self._elements.append(rel)

    def arrow(
        self,
        source: UseCaseRef,
        target: UseCaseRef,
        *,
        label: str | Label | None = None,
        style: LineStyleLike | None = None,
        direction: Direction | None = None,
        note: str | Label | None = None,
    ) -> None:
        """Add an arrow between elements.

        Args:
            source: Source element (string, Actor, or UseCase)
            target: Target element (string, Actor, or UseCase)
            label: Optional label
            style: Line style (color, pattern, thickness)
            direction: Layout direction hint (up, down, left, right)
            note: Note attached to the arrow
        """
        label_obj = Label(label) if isinstance(label, str) else label
        style_obj = coerce_line_style(style) if style else None
        note_obj = Label(note) if isinstance(note, str) else note
        direction_val = coerce_direction(direction)
        rel = Relationship(
            source=self._to_ref(source),
            target=self._to_ref(target),
            type="arrow",
            label=label_obj,
            style=style_obj,
            direction=direction_val,
            note=note_obj,
        )
        self._elements.append(rel)

    def link(
        self,
        source: UseCaseRef,
        target: UseCaseRef,
        *,
        label: str | Label | None = None,
        style: LineStyleLike | None = None,
        direction: Direction | None = None,
        note: str | Label | None = None,
    ) -> None:
        """Add a simple link (no arrow) between elements.

        Args:
            source: Source element (string, Actor, or UseCase)
            target: Target element (string, Actor, or UseCase)
            label: Optional label
            style: Line style (color, pattern, thickness)
            direction: Layout direction hint (up, down, left, right)
            note: Note attached to the link
        """
        label_obj = Label(label) if isinstance(label, str) else label
        style_obj = coerce_line_style(style) if style else None
        note_obj = Label(note) if isinstance(note, str) else note
        direction_val = coerce_direction(direction)
        rel = Relationship(
            source=self._to_ref(source),
            target=self._to_ref(target),
            type="association",
            label=label_obj,
            style=style_obj,
            direction=direction_val,
            note=note_obj,
        )
        self._elements.append(rel)

    def requires(
        self,
        base: UseCaseRef,
        required: UseCaseRef,
        *,
        style: LineStyleLike | None = None,
        direction: Direction | None = None,
        note: str | Label | None = None,
    ) -> None:
        """Add a mandatory requirement relationship (<<include>>).

        The base use case ALWAYS invokes the required use case.
        This is mandatory - the base cannot complete without the required.

        Args:
            base: Base use case that always invokes the required use case
            required: Use case that is always executed as part of base
            style: Line style (color, pattern, thickness)
            direction: Layout direction hint (up, down, left, right)
            note: Note attached to the relationship

        Example:
            d.requires(checkout, validate_cart)  # Checkout always validates cart
            d.requires(place_order, authenticate)  # Order requires login

        UML: <<include>> relationship
        """
        style_obj = coerce_line_style(style) if style else None
        note_obj = Label(note) if isinstance(note, str) else note
        direction_val = coerce_direction(direction)
        rel = Relationship(
            source=self._to_ref(base),
            target=self._to_ref(required),
            type="include",
            style=style_obj,
            direction=direction_val,
            note=note_obj,
        )
        self._elements.append(rel)

    def optional_for(
        self,
        extension: UseCaseRef,
        base: UseCaseRef,
        *,
        style: LineStyleLike | None = None,
        direction: Direction | None = None,
        note: str | Label | None = None,
    ) -> None:
        """Add an optional extension relationship (<<extends>>).

        The extension MAY be triggered during the base use case,
        but is not required for base to complete.

        Args:
            extension: Optional use case that may be triggered
            base: Base use case that may trigger the extension
            style: Line style (color, pattern, thickness)
            direction: Layout direction hint (up, down, left, right)
            note: Note attached to the relationship

        Example:
            d.optional_for(apply_coupon, checkout)  # Coupon is optional
            d.optional_for(express_shipping, place_order)  # Express is optional

        UML: <<extends>> relationship
        """
        style_obj = coerce_line_style(style) if style else None
        note_obj = Label(note) if isinstance(note, str) else note
        direction_val = coerce_direction(direction)
        rel = Relationship(
            source=self._to_ref(extension),
            target=self._to_ref(base),
            type="extends",
            style=style_obj,
            direction=direction_val,
            note=note_obj,
        )
        self._elements.append(rel)

    def generalizes(
        self,
        child: UseCaseRef,
        parent: UseCaseRef,
        *,
        style: LineStyleLike | None = None,
        direction: Direction | None = None,
        note: str | Label | None = None,
    ) -> None:
        """Add a generalization (extension) relationship.

        Args:
            child: Child actor/use case (string, Actor, or UseCase)
            parent: Parent actor/use case (string, Actor, or UseCase)
            style: Line style (color, pattern, thickness)
            direction: Layout direction hint (up, down, left, right)
            note: Note attached to the relationship
        """
        style_obj = coerce_line_style(style) if style else None
        note_obj = Label(note) if isinstance(note, str) else note
        direction_val = coerce_direction(direction)
        rel = Relationship(
            source=self._to_ref(child),
            target=self._to_ref(parent),
            type="extension",
            style=style_obj,
            direction=direction_val,
            note=note_obj,
        )
        self._elements.append(rel)

    def connect(
        self,
        hub: UseCaseRef,
        spokes: list[UseCaseRef],
        *,
        label: str | Label | None = None,
        style: LineStyleLike | None = None,
        direction: Direction | None = None,
    ) -> None:
        """Connect a hub element to multiple spoke elements.

        Creates arrows from hub to each spoke. Useful for connecting an actor
        to multiple use cases.

        Args:
            hub: Central element (e.g., actor)
            spokes: List of elements to connect to (e.g., use cases)
            label: Optional label for all arrows
            style: Line style (color, pattern, thickness)
            direction: Layout direction hint (up, down, left, right)
        """
        for spoke in spokes:
            self.arrow(hub, spoke, label=label, style=style, direction=direction)

    def note(
        self,
        content: str | Label,
        *,
        position: Literal["left", "right", "top", "bottom"] = "right",
        target: UseCaseRef | None = None,
        color: ColorLike | None = None,
    ) -> None:
        """Add a note."""
        text = content.text if isinstance(content, Label) else content
        if not text:
            raise ValueError("Note content cannot be empty")
        content_label = Label(content) if isinstance(content, str) else content
        target_ref = self._to_ref(target) if target else None
        n = UseCaseNote(
            content=content_label,
            position=position,
            target=target_ref,
            color=color,
        )
        self._elements.append(n)

    @contextmanager
    def rectangle(
        self,
        name: str,
        *,
        stereotype: str | Stereotype | None = None,
        style: StyleLike | None = None,
    ) -> Iterator["_ContainerBuilder"]:
        """Create a rectangle container.

        Usage:
            with d.rectangle("System") as r:
                r.usecase("Feature")
        """
        builder = _ContainerBuilder("rectangle", name, stereotype, style)
        yield builder
        self._elements.append(builder._build())

    @contextmanager
    def package(
        self,
        name: str,
        *,
        stereotype: str | Stereotype | None = None,
        style: StyleLike | None = None,
    ) -> Iterator["_ContainerBuilder"]:
        """Create a package container.

        Usage:
            with d.package("Module") as p:
                p.usecase("Feature")
        """
        builder = _ContainerBuilder("package", name, stereotype, style)
        yield builder
        self._elements.append(builder._build())


class _ContainerBuilder(_BaseUseCaseBuilder):
    """Builder for containers."""

    def __init__(
        self,
        type: ContainerType,
        name: str,
        stereotype: str | Stereotype | None,
        style: StyleLike | None,
    ) -> None:
        if not name:
            raise ValueError("Container name cannot be empty")
        super().__init__()
        self._type = type
        self._name = name
        self._stereotype = (
            Stereotype(name=stereotype) if isinstance(stereotype, str) else stereotype
        )
        self._style = validate_style_background_only(style, "Container")

    def _build(self) -> Container:
        """Build the container."""
        return Container(
            name=self._name,
            type=self._type,
            elements=tuple(self._elements),
            stereotype=self._stereotype,
            style=self._style,
        )


class UseCaseDiagramBuilder(_BaseUseCaseBuilder):
    """Builder for complete use case diagrams.

    Usage:
        with usecase_diagram(title="Shopping") as d:
            user = d.actor("Customer")
            browse = d.usecase("Browse")
            d.arrow(user, browse)

        print(d.render())
    """

    def __init__(
        self,
        *,
        title: str | None = None,
        actor_style: ActorStyle | None = None,
        left_to_right: bool = False,
        caption: str | None = None,
        header: str | Header | None = None,
        footer: str | Footer | None = None,
        legend: str | Legend | None = None,
        scale: float | Scale | None = None,
    ) -> None:
        super().__init__()
        self._title = title
        self._actor_style = actor_style
        self._left_to_right = left_to_right
        self._caption = caption
        self._header = Header(header) if isinstance(header, str) else header
        self._footer = Footer(footer) if isinstance(footer, str) else footer
        self._legend = Legend(legend) if isinstance(legend, str) else legend
        self._scale = Scale(factor=scale) if isinstance(scale, (int, float)) else scale

    def build(self) -> UseCaseDiagram:
        """Build the complete use case diagram."""
        return UseCaseDiagram(
            elements=tuple(self._elements),
            title=self._title,
            actor_style=self._actor_style,
            left_to_right=self._left_to_right,
            caption=self._caption,
            header=self._header,
            footer=self._footer,
            legend=self._legend,
            scale=self._scale,
        )

    def render(self) -> str:
        """Build and render the diagram to PlantUML text.

        Convenience method combining build() and render() in one call.
        """
        from ..renderers import render

        return render(self.build())


@contextmanager
def usecase_diagram(
    *,
    title: str | None = None,
    actor_style: ActorStyle | None = None,
    left_to_right: bool = False,
    caption: str | None = None,
    header: str | Header | None = None,
    footer: str | Footer | None = None,
    legend: str | Legend | None = None,
    scale: float | Scale | None = None,
) -> Iterator[UseCaseDiagramBuilder]:
    """Create a use case diagram with context manager syntax.

    Usage:
        with usecase_diagram(title="Shopping System") as d:
            user = d.actor("Customer")
            browse = d.usecase("Browse Products")
            d.arrow(user, browse)

        print(d.render())

    Args:
        title: Optional diagram title
        actor_style: Actor style ("default", "awesome", "hollow")
        left_to_right: Use left to right layout direction
        caption: Optional diagram caption
        header: Optional header text or Header object
        footer: Optional footer text or Footer object
        legend: Optional legend text or Legend object
        scale: Optional scale factor or Scale object

    Yields:
        A UseCaseDiagramBuilder for adding diagram elements
    """
    builder = UseCaseDiagramBuilder(
        title=title,
        actor_style=actor_style,
        left_to_right=left_to_right,
        caption=caption,
        header=header,
        footer=footer,
        legend=legend,
        scale=scale,
    )
    yield builder
